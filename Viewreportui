import { useEffect, useState } from "react";
import {
  Box,
  Paper,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Stack,
  Container,
  Button,
  Card,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Link,
  CardContent,
  Grid,
  IconButton,
} from "@mui/material";
import { AdapterDayjs } from "@mui/x-date-pickers/AdapterDayjs";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import {
  Download,
  Visibility,
  PictureAsPdf,
  InsertDriveFile,
  Description,
  ContentPasteOffTwoTone,
  DownloadForOfflineTwoTone,
  VisibilityRounded,
} from "@mui/icons-material";
import useApi from "../../../hooks/useApi";

// --- Helper Functions ---

const isViewable = (mimeType) => {
  if (!mimeType) return false;
  return (
    mimeType.startsWith("application/pdf") ||
    mimeType.startsWith("image/") ||
    mimeType.startsWith("text/")
  );
};

const base64ToBlob = (base64, mimeType) => {
  const byteCharacters = atob(base64);
  const byteArrays = [];
  const sliceSize = 512;
  for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    const slice = byteCharacters.slice(offset, offset + sliceSize);
    const byteNumbers = new Array(slice.length);
    for (let i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    byteArrays.push(byteArray);
  }
  return new Blob(byteArrays, { type: mimeType });
};

const getFileIcon = (fileName) => {
  if (!fileName) return <InsertDriveFile />;
  const extension = fileName.split(".").pop().toLowerCase();
  switch (extension) {
    case "pdf":
      return <PictureAsPdf />;
    case "xlsx":
    case "xls":
      return <Description />;
    default:
      return <InsertDriveFile />;
  }
};

// --- Viewer Components ---

const PdfViewer = ({ objectUrl, fileName }) => (
  <iframe
    src={objectUrl}
    title={fileName}
    style={{ width: "100%", height: "100%", border: "none" }}
  />
);

const ImageViewer = ({ objectUrl, fileName }) => (
  <Box
    sx={{
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      p: 2,
      backgroundColor: "grey.200",
    }}
  >
    <img
      src={objectUrl}
      alt={fileName}
      style={{
        maxWidth: "100%",
        maxHeight: "100%",
        objectFit: "contain",
      }}
    />
  </Box>
);

const TextViewer = ({ objectUrl }) => {
  const [content, setContent] = useState("");
  useEffect(() => {
    const reader = new FileReader();
    fetch(objectUrl)
      .then((res) => res.blob())
      .then((blob) => {
        reader.readAsText(blob);
        reader.onload = () => setContent(reader.result);
      });
  }, [objectUrl]);

  return (
    <pre
      style={{
        whiteSpace: "pre-wrap",
        wordWrap: "break-word",
        overflow: "auto",
        height: "100%",
        color: "#FFFFFF", // Fixed: Light text for dark dialog
        backgroundColor: "rgba(0, 0, 0, 0.2)", // Added for contrast
        padding: "16px",
        margin: 0,
        borderRadius: "4px",
      }}
    >
      {content}
    </pre>
  );
};

const renderViewer = (objectUrl, file) => {
  const mimeType = file?.type;
  if (mimeType?.startsWith("application/pdf")) {
    return <PdfViewer objectUrl={objectUrl} fileName={file.name} />;
  }
  if (mimeType?.startsWith("image/")) {
    return <ImageViewer objectUrl={objectUrl} fileName={file.name} />;
  }
  if (mimeType?.startsWith("text/")) {
    return <TextViewer objectUrl={objectUrl} />;
  }
  return (
    <Card>
      <CardContent>
        <Typography variant="h5" component="div">
          Preview Unavailable
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Cannot display the content of this file type.
        </Typography>
      </CardContent>
    </Card>
  );
};

//..........................Report Viewer Dialog.................................//
const ReportDialog = (props) => {
  return (
    <Dialog
      sx={{
        "& .MuiPaper-root": {
          backgroundColor: "#7fa0b5",
        },
      }}
      slotProps={{
        backdrop: {
          sx: {
            backgroundColor: "rgba(0, 0, 0, 0.5)",
          },
        },
      }}
      fullWidth
      maxWidth="lg" // Use maxWidth for better responsiveness
      onClose={() => props.setview(false)}
      open={props.open}
    >
      <DialogTitle>{props.fileName || "File Viewer"}</DialogTitle>
      <DialogContent sx={{ height: "75vh" }}>
        <Box sx={{ mt: 1, mb: 1, height: "100%" }}>
          {renderViewer(props.url, props.file)}
        </Box>
      </DialogContent>
      <DialogActions>
        {props.url && (
          // Fixed: Added download attribute with the correct fileName
          <Link href={props.url} download={props.fileName}>
            <Button sx={{ color: "white" }}>Download</Button>
          </Link>
        )}
      </DialogActions>
    </Dialog>
  );
};

//................................................................................//

export default function GlifReports() {
  const [repTypes, setRepTypes] = useState([]);
  const [selectedReport, setReport] = useState(""); // Default to empty string
  const [selectedDate, setDate] = useState(null);
  const [isViewing, setIsViewing] = useState(false);
  const [fileDetails, setFileDetails] = useState(null);
  const [objectUrl, setObjectUrl] = useState(null);
  const { callApi } = useApi();
  const [isLoading, setIsLoading] = useState(false);
  const [noReportMessage, setNoReportMessage] = useState(
    "No report fetched yet. Select a report type and date to get started."
  );

  //Getting Reports Types list
  useEffect(() => {
    async function fetchData() {
      setIsLoading(true);
      try {
        const data = await callApi("RS/reports/types", { roleId: 56 }, "POST");
        setRepTypes(data.data || []);
      } catch (error) {
        console.error("Failed to fetch report types:", error);
      }
      setIsLoading(false);
    }
    fetchData();
  }, [callApi]);

  // Clean up object URL to prevent memory leaks
  useEffect(() => {
    return () => {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    };
  }, [objectUrl]);

  //setting selected report
  const handleSelect = (event) => {
    setReport(event.target.value);
  };

  //Fetching Report data
  async function handleFetchReportData() {
    if (!selectedReport || !selectedDate) return;

    setIsLoading(true);
    setObjectUrl(null);
    setFileDetails(null);
    setNoReportMessage(null); // Clear previous messages

    // Revoke previous URL if it exists
    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
    }

    try {
      const response = await callApi(
        "RS/reports/download",
        {
          fileName: selectedReport,
          date: selectedDate.format("YYYY-MM-DD"),
          roleId: 56,
        },
        "POST"
      );

      if (!response?.success) {
        setNoReportMessage(
          response?.message ||
            "No report file found for the selected type and date."
        );
        return;
      }

      if (!response.data?.fileContent || !response.data?.fileType) {
        setNoReportMessage(
          "No file content or file type was received. Please try again."
        );
        return;
      }

      const blobObject = base64ToBlob(
        response.data.fileContent,
        response.data.fileType
      );
      const newObjectUrl = URL.createObjectURL(blobObject);

      setFileDetails({
        name: response.data.fileName,
        type: response.data.fileType,
      });
      setObjectUrl(newObjectUrl);
    } catch (error) {
      console.error("Failed to fetch report data:", error);
      setNoReportMessage("Failed to fetch report. Please try again.");
    } finally {
      setIsLoading(false);
    }
  }

  // Fixed: Added fileName parameter and set link.download
  function handleDownloadReport(url, fileName) {
    const link = document.createElement("a");
    link.href = url;
    link.download = fileName; // This forces the download with the correct name
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link); // Clean up
  }

  return (
    <Container maxWidth={false} disableGutters>
      <Stack spacing={4}>
        {/* Fixed: Changed <card> to <Card> */}
        <Card>
          <Paper sx={{ p: 3, width: "100%", textAlign: "center" }} elevation={3}>
            {/* Cleaned up: Used Box for easier centering */}
            <Box
              sx={{
                display: "flex",
                justifyContent: "center",
                mb: 2,
              }}
            >
              <DownloadForOfflineTwoTone
                sx={{
                  height: 70,
                  width: 70,
                }}
              />
            </Box>
            <Typography variant="h6" component="h1" gutterBottom>
              Utilize the required report type and date criteria below to
              precisely define and retrieve the required reports.
            </Typography>
            <Typography variant="h6" component="h1" gutterBottom>
              The generated reports can be viewed on-screen or downloaded for
              archival.
            </Typography>
          </Paper>
        </Card>

        <Card>
          <Paper
            sx={{
              py: 3,
              px: 3,
              width: "100%",
              height: "100%",
              bgcolor: "#054c70ff",
            }}
            elevation={2}
          >
            <Box
              sx={{
                display: "flex",
                flexDirection: { xs: "column", md: "row" }, // Stack on mobile
                gap: 2, // Add gap between items
                justifyContent: "space-between",
                borderRadius: 3,
                padding: { xs: 2, md: 4 }, // Adjust padding for mobile
                bgcolor: "#2b5a79ff",
                boxShadow: 6,
              }}
            >
              {/* Dropdown Menu */}
              <FormControl sx={{ minWidth: "25%", flexGrow: 1 }}>
                <InputLabel id="menu-select-label">Select a report</InputLabel>
                <Select
                  labelId="menu-select-label"
                  id="menu-select"
                  value={selectedReport}
                  label="Select a Report"
                  onChange={handleSelect}
                >
                  {repTypes.map((item) => (
                    <MenuItem key={item.reportName} value={item.fileName}>
                      {item.reportName}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>

              {/* Date Picker */}
              <FormControl sx={{ minWidth: "25%", flexGrow: 1 }}>
                <LocalizationProvider dateAdapter={AdapterDayjs}>
                  <DatePicker
                    label="Select Report Date"
                    value={selectedDate}
                    onChange={(newDate) => setDate(newDate)}
                  />
                </LocalizationProvider>
              </FormControl>
              <Button
                disabled={!(selectedReport && selectedDate) || isLoading}
                sx={{
                  height: "56px", // Match input height
                  flexShrink: 0, // Prevent button from shrinking
                }}
                endIcon={<VisibilityRounded />}
                variant="contained"
                onClick={handleFetchReportData}
              >
                {isLoading ? "Fetching..." : "Fetch Report"}
              </Button>
            </Box>

            <Box
              sx={{
                mt: 4,
                display: "flex",
                alignItems: "center", // Center content vertically
                border: "1px dashed #6ea9c4ff",
                p: 2,
                borderRadius: 3,
                minHeight: 80, // Use minHeight
                width: "100%",
              }}
            >
              {fileDetails ? (
                <Grid
                  container
                  spacing={2}
                  sx={{ width: "100%", alignItems: "center" }}
                >
                  <Grid
                    item
                    xs={12}
                    md={6}
                    sx={{
                      display: "flex",
                      alignItems: "center",
                      gap: 2,
                    }}
                  >
                    {getFileIcon(fileDetails.name)}
                    <Typography
                      variant="h6"
                      color="text.secondary"
                      fontWeight="600"
                      sx={{ wordBreak: "break-all" }} // Handle long filenames
                    >
                      {fileDetails.name}
                    </Typography>
                  </Grid>

                  <Grid
                    item
                    xs={12}
                    md={6}
                    sx={{
                      display: "flex",
                      flexDirection: "row",
                      justifyContent: "flex-end",
                      alignItems: "center",
                      gap: 2,
                    }}
                  >
                    {objectUrl && fileDetails && (
                      <IconButton
                        // Fixed: Call handler with both URL and name
                        onClick={() =>
                          handleDownloadReport(objectUrl, fileDetails.name)
                        }
                        size="large"
                        sx={{
                          color: "text.secondary",
                          border: "1px solid white",
                          padding: "7px",
                          "&:hover": {
                            backgroundColor: "rgba(255, 255, 255, 0.1)",
                          },
                        }}
                      >
                        <Download />
                      </IconButton>
                    )}
                    <IconButton
                      onClick={() => setIsViewing(true)}
                      size="large"
                      disabled={!isViewable(fileDetails.type)}
                      color="text.secondary"
                      sx={{
                        border: "1px solid",
                        padding: "7px",
                        "&:hover": {
                          backgroundColor: "rgba(25, 118, 210, 0.1)",
                        },
                      }}
                    >
                      <Visibility />
                    </IconButton>
                  </Grid>

                  {!isViewable(fileDetails.type) && (
                    <Grid
                      item
                      xs={12}
                      sx={{
                        display: "flex",
                        justifyContent: "flex-end",
                        pt: 1, // Add some padding top
                      }}
                    >
                      <Typography variant="caption" color="error.light">
                        Preview is not available for this file type, please
                        download directly.
                      </Typography>
                    </Grid>
                  )}
                </Grid>
              ) : (
                <Box
                  sx={{
                    display: "flex",
                    alignItems: "center",
                    width: "100%",
                    gap: 2, // Add gap
                  }}
                >
                  <ContentPasteOffTwoTone
                    sx={{ fontSize: 26, color: "text.secondary" }}
                  />
                  <Typography variant="body1" color="text.secondary">
                    {noReportMessage}
                  </Typography>
                </Box>
              )}
            </Box>
          </Paper>
        </Card>
      </Stack>
      <ReportDialog
        open={isViewing}
        setview={setIsViewing}
        url={objectUrl}
        file={fileDetails}
        fileName={fileDetails?.name} // Fixed: Pass the correct name
      />
    </Container>
  );
}
