package com.fincore.gateway.Config;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.interfaces.RSAPublicKey;
import java.util.Base64;

/**
 * Creates a ReactiveJwtDecoder based on properties:
 * security.jwt.mode = hmac | rsa
 * <p>
 * HMAC:
 * - security.jwt.hmac-base64-secret = base64 of your HS256 secret bytes (>= 256-bit)
 * <p>
 * RSA:
 * - security.jwt.rsa-public = PEM public key (-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----)
 * <p>
 * Switch environments by only changing properties. No code change.
 */
@Configuration
public class JwtDecoderConfig {

    @Value("${security.jwt.mode:hmac}")
    private String mode;

    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacBase64Secret;

    @Value("${security.jwt.rsa-public:}")
    private String rsaPublicPem;

    @PostConstruct
    void sanity() {
        if ("hmac".equalsIgnoreCase(mode)) {
            if (hmacBase64Secret == null || hmacBase64Secret.isBlank()) {
                throw new IllegalStateException("HMAC mode selected but security.jwt.hmac-base64-secret is empty");
            }
        } else if ("rsa".equalsIgnoreCase(mode)) {
            if (rsaPublicPem == null || rsaPublicPem.isBlank()) {
                throw new IllegalStateException("RSA mode selected but security.jwt.rsa-public is empty");
            }
        } else {
            throw new IllegalStateException("Unsupported security.jwt.mode: " + mode + " (use 'hmac' or 'rsa')");
        }
    }

    @Bean
    public ReactiveJwtDecoder jwtDecoder() {
        if ("hmac".equalsIgnoreCase(mode)) {
            // Decode base64 to raw bytes and create a SecretKey for HS256 verification
            byte[] secretBytes = Base64.getDecoder().decode(hmacBase64Secret);
            SecretKey key = new SecretKeySpec(secretBytes, "HmacSHA256");
            return NimbusReactiveJwtDecoder.withSecretKey(key).build();
        } else {
            // Parse RSA public key for RS256 verification
            RSAPublicKey publicKey = KeyUtils.parseRsaPublicKey(rsaPublicPem);
            return NimbusReactiveJwtDecoder.withPublicKey(publicKey).build();
        }
    }
}





-----

package com.fincore.gateway.Config;

import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

/**
 * Utility to parse a PEM RSA public key string into RSAPublicKey
 */
public class KeyUtils {

    public static RSAPublicKey parseRsaPublicKey(String pem) {
        try {
            String clean = pem
                    .replace("-----BEGIN PUBLIC KEY-----", "")
                    .replace("-----END PUBLIC KEY-----", "")
                    .replaceAll("\\s", "");
            byte[] decoded = Base64.getDecoder().decode(clean);
            X509EncodedKeySpec spec = new X509EncodedKeySpec(decoded);
            KeyFactory kf = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) kf.generatePublic(spec);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new IllegalArgumentException("Invalid RSA public key", e);
        }
    }
}




------


package com.fincore.gateway.Config;

import com.fincore.gateway.Service.TokenSessionValidator;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.SecurityWebFiltersOrder;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.web.server.WebFilter;

@Slf4j
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    // Bypass paths List
    @Value("${security.jwt.bypass-paths}")
    private String[] bypassPaths;

    private final TokenSessionValidator tokenSessionValidator;


    public SecurityConfig(TokenSessionValidator tokenSessionValidator) {
        this.tokenSessionValidator = tokenSessionValidator;
    }

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        System.out.println("security web filter chain");
        return http
                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers("/auth/login", "/actuator/info","/actuator/health").permitAll()
//                        .pathMatchers(bypassPaths).permitAll()
                        .anyExchange().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))
                //  Run Redis validation right before authorization checks
                .addFilterAt(redisValidationFilter(), SecurityWebFiltersOrder.AUTHORIZATION)
                .build();
    }

    private WebFilter redisValidationFilter() {
        return (exchange, chain) -> {
            log.info("RedisValidationFilter invoked for path={}", exchange.getRequest().getPath());

            return exchange.getPrincipal()
                    .cast(Authentication.class)
                    .doOnNext(auth -> log.info("Principal = {}", auth))
                    .flatMap(auth -> tokenSessionValidator.validateWithRedis(auth)
                            .doOnSuccess(validAuth -> log.info(" Redis validated for {}", validAuth.getName()))
                            .flatMap(validAuth -> chain.filter(exchange))
                    )
                    .switchIfEmpty(chain.filter(exchange))
                    .onErrorResume(e -> {
                        log.error("!! RedisValidationFilter error: {}", e.getMessage());
                        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                        return exchange.getResponse().setComplete();
                    });
        };
    }

}


--------

package com.fincore.gateway.Controller;


import com.fincore.gateway.JwtUtil.HmacJwtUtil;
import com.fincore.gateway.Service.TokenSessionValidator;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.Base64;
import java.util.Map;

/**
 * Test-only endpoints to exercise the gateway+redis locally.
 * - POST /auth/login  {username} -> returns HS256 token (sub + jti) and registers session in Redis
 * - POST /auth/logout            -> blacklists current token jti in Redis
 * <p>
 * In PRODUCTION:
 * - Remove this controller.
 * - Your Login service should write to Redis: USR:<user>=<jti>; On logout write BL:<jti>=1.
 */
@Slf4j
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {

    private final TokenSessionValidator validator;

    @Value("${security.jwt.mode:hmac}")
    private String mode;

    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacSecret;

    @Value("${security.jwt.ttl-seconds:900}")
    private long ttlSeconds;

    @PostMapping("/login")
    public Mono<ResponseEntity<Map<String, Object>>> login(@RequestBody LoginReq req) {
        log.info("login req={}", req);
        if (!"hmac".equalsIgnoreCase(mode)) {
            return Mono.just(ResponseEntity.badRequest().body(Map.of(
                    "error", "This demo /auth/login issues HS256 tokens only. Switch to security.jwt.mode=hmac for local tests."
            )));
        }
        log.info("login accept={}", req);
        // Simple demo: accept any username
        if (hmacSecret == null || hmacSecret.isBlank()) {
            return Mono.just(ResponseEntity.internalServerError().body(Map.of("error", "Missing hmac secret")));
        }

        // Generate a HS256 JWT (sub + jti + exp)
        String token = HmacJwtUtil.generate(hmacSecret, req.getUsername(), ttlSeconds);
        log.info("Generated token={}", token);


        // Extract jti again so we can store it; JJWT returns it inside the token, but we avoid parsing here:
        // Small parse just to get jti back (safe because we just created it).
        var parser = io.jsonwebtoken.Jwts.parser().verifyWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(
                Base64.getDecoder().decode(hmacSecret))).build();
        var claimsJws = parser.parseSignedClaims(token);
        String jti = claimsJws.getPayload().getId();

        log.info("Jti from claims claimsJws.getPayload().getId(){}", jti);

        return validator.registerUserSession(req.getUsername(), jti)
                .thenReturn(ResponseEntity.ok(Map.of(
                        "accessToken", token,
                        "tokenType", "Bearer",
                        "expiresIn", ttlSeconds,
                        "sub", req.getUsername(),
                        "jti", jti
                )));
    }

   /* @PostMapping("/logout")
    public Mono<ResponseEntity<String>> logout(@AuthenticationPrincipal Jwt jwt) {
        String jti = jwt.getId();
        String username = jwt.getSubject();

        return redisTemplate.opsForValue()
                .set("BL:" + jti, "true", Duration.ofSeconds(TOKEN_TTL_SECONDS))
                .then(redisTemplate.delete("USR:" + username))
                .thenReturn(ResponseEntity.ok("User " + username + " logged out successfully"));
    }*/

    @Data
    public static class LoginReq {
        private String username;
        private String password;
    }
}




--------------------



package com.fincore.gateway.Controller;

import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.Map;

/**
 * Protected endpoint to verify auth+redis policies easily.
 */
@RestController
@RequestMapping("/secure")
public class ProtectedEchoController {

    @GetMapping("/hello")
    public Mono<Map<String, Object>> hello(JwtAuthenticationToken auth) {
        return Mono.just(Map.of(
                "message", "Hello " + auth.getName(),
                "sub", auth.getToken().getSubject(),
                "jti", auth.getToken().getId()
        ));
    }
}





-----------------


package com.fincore.gateway.JwtUtil;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.SecretKey;
import java.time.Instant;
import java.util.Base64;
import java.util.Date;
import java.util.UUID;

/**
 * Minimal HS256 token generator for local tests (NOT for prod).
 */
@Slf4j
public final class HmacJwtUtil {

    private HmacJwtUtil() {
    }

    public static String generate(String base64Secret, String subject, long ttlSeconds) {
        byte[] secret = Base64.getDecoder().decode(base64Secret);
        SecretKey key = Keys.hmacShaKeyFor(secret);

        Instant now = Instant.now();
        Instant exp = now.plusSeconds(ttlSeconds);
        log.info("Generated exp in Seconds={}", exp);
        String jti = UUID.randomUUID().toString();
        log.info("Jti generated={}", jti);

        return Jwts.builder()
                .subject(subject)
                .id(jti)
                .issuedAt(Date.from(now))
                .expiration(Date.from(exp))
                .signWith(key)      // HS256
                .compact();
    }
}







----------------


package com.fincore.gateway.Service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.Duration;

@Component
public class TokenSessionValidator {

    private static final Logger log = LoggerFactory.getLogger(TokenSessionValidator.class);
    // Redis key prefixes
    private static final String USER_PREFIX = "USR:";
    private static final String BLACKLIST_PREFIX = "BL:";
    // Expiry = same as JWT expiry (example: 15 minutes, should match your JwtService config)
    private static final Duration TOKEN_TTL = Duration.ofMinutes(15);
    private final ReactiveStringRedisTemplate redisTemplate;

    public TokenSessionValidator(ReactiveStringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    /**
     * Called during login to register a new session for the user.
     * 1. Blacklists old JTI if exists
     * 2. Stores new JTI in Redis with expiry
     */
    public Mono<Void> registerUserSession(String username, String newJti) {
        String userKey = USER_PREFIX + username;

        log.info("Inside registerUserSession method " + userKey);

        return redisTemplate.opsForValue().get(userKey)
                .flatMap(oldJti -> {
                    if (oldJti != null) {
                        log.info(" Found old session for user={} -> blacklisting oldJti={}", username, oldJti);
                        return blacklistToken(oldJti);
                    }
                    return Mono.empty();
                })
                .then(redisTemplate.opsForValue()
                        .set(userKey, newJti, TOKEN_TTL)
                        .doOnSuccess(v -> log.info(" Registered new session in Redis for user={} jti={}", username, newJti))
                        .then()
                );
    }

    /**
     *  Blacklist a token (on logout or replacement).
     */
    public Mono<Boolean> blacklistToken(String jti) {
        String key = BLACKLIST_PREFIX + jti;
        return redisTemplate.opsForValue().set(key, "true", TOKEN_TTL)
                .doOnSuccess(v -> log.info(" Blacklisted token jti={}", jti));
    }

    /**
     *  Clear session for a given user (e.g., on logout).
     */
    public Mono<Boolean> clearUserSession(String username) {
        return redisTemplate.delete(USER_PREFIX + username)
                .map(deleted -> {
                    if (deleted > 0) {
                        log.info(" Cleared session for user={}", username);
                        return true;
                    }
                    return false;
                });
    }

    /**
     * Validate token against Redis.
     * - Reject if blacklisted
     * - Reject if not equal to the latest session JTI
     */
    public Mono<Authentication> validateWithRedis(Authentication authentication) {
        if (!(authentication instanceof JwtAuthenticationToken jwtAuth)) {
            log.warn("Skipping validation: not a JwtAuthenticationToken -> {}", authentication);
            return Mono.error(new BadCredentialsException("Invalid authentication type"));
        }

        Jwt jwt = jwtAuth.getToken();
        String username = jwt.getSubject();
        String jti = jwt.getId();

        if (jti == null) {
            log.error("Token missing JTI claim -> rejecting token for user={}", username);
            return Mono.error(new BadCredentialsException("Missing token ID (jti)"));
        }

        log.info(" Validating token for user={} with jti={}", username, jti);

        return redisTemplate.hasKey(BLACKLIST_PREFIX + jti)
                .flatMap(isBlacklisted -> {
                    if (Boolean.TRUE.equals(isBlacklisted)) {
                        log.warn(" Token is blacklisted -> jti={}, user={}", jti, username);
                        return Mono.error(new BadCredentialsException("Token revoked"));
                    }

                    return redisTemplate.opsForValue().get(USER_PREFIX + username)
                            .flatMap(currentJti -> {
                                log.info(" Redis stored JTI for user={} is {}", username, currentJti);

                                if (currentJti == null) {
                                    log.warn(" No active session found in Redis for user={} -> rejecting", username);
                                    return Mono.error(new BadCredentialsException("No active session"));
                                }

                                if (!currentJti.equals(jti)) {
                                    log.warn(" Token mismatch for user={} -> expected={}, got={}",
                                            username, currentJti, jti);
                                    return Mono.error(new BadCredentialsException("Another session is active"));
                                }

                                log.info(" Token validation success for user={} with jti={}", username, jti);
                                return Mono.just(authentication);
                            });
                });
    }
}








----------------------




package com.fincore.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Api Gateway Application (Spring Cloud Gateway - WebFlux).
 */
@SpringBootApplication
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}



-----------------------------
application.yaml


spring:
  application:
    name: api-gateway

  profiles:
    active: dev

  main:
    web-application-type: reactive

#  cloud:
  gateway:
    routes:
      - id: product-service
        uri: http://product-service:8081
        predicates:
          - Path=/Product/**
      - id: fincore-service
        uri: http://fincore-service:8089
        predicates:
          - Path=/Fincore/**
  kubernetes:
    discovery:
      enabled: false

# ========== DB Details ==========
  datasource:
    url: jdbc:oracle:thin:@10.191.216.58:1522:crsprod
    username: fnsonli
    password: Password#1234

server:
  port: 8080

# ========== JWT MODE ==========
security:
  jwt:
    mode: hmac
    hmac-base64-secret: ""
    # for prod, if using RSA
    rsa-public: ""
    ttl-seconds: 900
    bypass-paths: /auth/login,/actuator/**

# ========== Redis ==========
redis:
  enabled: true
  data:
    redis:
      host: redis
      port: 6379
      database: 0
      # password: ""  # if needed

# ========== Actuator ==========
management:
  endpoints:
    web:
      exposure:
        include: health,info
  endpoint:
    health:
      show-details: always

# ========== Logging ==========
logging:
  pattern:
    console: "%d{yyyy-MM-dd :: HH:mm:ss.SSS ||} %highlight(%-5level:: %file: | %line |){ERROR=bold red, WARN=yellow, INFO=white, DEBUG=green, TRACE=green} :: %msg%n"





--------------------

application-dev-yaml

security:
  jwt:
    mode: hmac
    # example 32-byte (256-bit) base64-encoded secret
    hmac-base64-secret: bWV0aGlvbnlsdGhyZW9ueWx0aHJlb255bGdsdXRhbWlueWxhbGFueWw=
#    bypass-paths: /auth/login,/actuator/**

spring:
  data:
    redis:
#      host: redis
#      use "localhost" when run locally
      host: localhost
      port: 6379
      database: 0

redis:
  enabled: true








---------------

spring:
  config:
    activate:
      on-profile: prod
  data:

  # ========== Redis Config ==========
    redis:
      host: ${REDIS_HOST}
      port: ${REDIS_PORT}
      database: ${REDIS_DB}
      password: ${REDIS_PASSWORD}

  # ========== DB Details ==========
  datasource:
    url: jdbc:oracle:thin:@${DB_HOST}:${DB_PORT}:${DB_SID}
    username: ${DB_USER}
    password: ${DB_PASS}

# ========== JWT Secrets ==========
security:
  jwt:
    hmac-base64-secret: ${JWT_SECRET}







------------------------------

DockerFile

# Use Red Hat UBI with OpenJDK 17 (if accessible internally)
FROM cimg/openjdk:24.0.2-node

# Set working directory inside container
WORKDIR /app

ARG JAR_FILE=target/*.jar

# Copy JAR file into the container
COPY ${JAR_FILE} app.jar

EXPOSE 8080
# Run your Spring Boot app
CMD ["java", "-jar", "app.jar"]


